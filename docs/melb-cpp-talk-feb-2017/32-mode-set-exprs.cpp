//!clang++ -std=c++11 -Weverything -Wno-c++98-compat 32-mode-set-exprs.cpp -o z32.out && ./z32.out

// Implement operator| for combining Modes into a ModeSet

// Manually check that mode expressions correctly construct the
// expected ModeSet types by uncommenting display_t instances one-by-one.

#include <iostream> // cout
#include <type_traits> // is_same

// ............................................................................
// Debug util

// display_t is a debugging type. If you use it, the compile will fail with an error.
// From the compiler error message you can read off the type of T.
// Enable one of the instantiations of display_t below to check the type
// generated by the test cases.
template <typename T>
struct display_t{
    using type = typename T::display_T_by_referencing_a_non_existant_type;
};

// ............................................................................
// Library code

template<typename T>
struct ModeType {}; // aka mode category

template<typename T, T X>
struct Mode : ModeType<T> {
    constexpr Mode() {}
};

template<typename... Ts> // C++11: variadic template
struct ModeSet {};

// ............................................................................

enum class LineStyle { dotted, dashed, solid };

constexpr Mode<LineStyle, LineStyle::dotted> dotted;
constexpr Mode<LineStyle, LineStyle::dashed> dashed;
constexpr Mode<LineStyle, LineStyle::solid> solid;

enum class EndStyle { no_ends, arrows, circles };

constexpr Mode<EndStyle, EndStyle::no_ends> no_ends;
constexpr Mode<EndStyle, EndStyle::arrows> arrows;
constexpr Mode<EndStyle, EndStyle::circles> circles;

enum class RenderStyle { plain, sketchy, painterly };

constexpr Mode<RenderStyle, RenderStyle::plain> plain;
constexpr Mode<RenderStyle, RenderStyle::sketchy> sketchy;
constexpr Mode<RenderStyle, RenderStyle::painterly> painterly;

enum class Colour { red, green, blue }; // you wouldn't use modes for color, just for testing

constexpr Mode<Colour, Colour::red> red;
constexpr Mode<Colour, Colour::green> green;
constexpr Mode<Colour, Colour::blue> blue;

// ModeSet expressions:

// Mode | Mode -> ModeSet
// e.g.: a|b -> <a,b>
// Mode<T,X> | Mode<U,Y> -> ModeSet< Mode<T,X> | Mode<U,Y> >

template<typename T, T X, typename U, U Y>
constexpr ModeSet<Mode<T,X>, Mode<U,Y> > operator|(Mode<T,X>, Mode<U,Y>) // C++11: constexpr
{
    return {};
}

using example1_t = decltype(dotted|arrows);
//constexpr display_t<example1_t> X;
//X: ModeSet<Mode<LineStyle, LineStyle::dotted>, Mode<EndStyle, EndStyle::arrows>


// ModeSet | Mode -> ModeSet
// e.g.: (a|b|...)|c -> <a,b,...,c>
// ModeSet<Ts...> | Mode<U,Y> -> ModeSet<Ts..., Mode<U,Y> >

template<typename... Ts, typename U, U Y>
constexpr ModeSet<Ts..., Mode<U,Y> > operator|(ModeSet<Ts...>, Mode<U,Y>)
{
    return {};
}

using example3a_t = decltype((dotted|arrows)|sketchy);
//constexpr display_t<example3a_t> X;

// NOTE: since operator| is left associative, that's all we
// need for expressions.

using example3b_t = decltype(dotted|arrows|sketchy);
using example3c_t = decltype(dotted|arrows|sketchy|green);

// But define the other cases to allow parenthesis and storing
// sub-expressions in types.


// Mode | ModeSet -> ModeSet
// e.g.: a|(b|c|...) -> <a,b,c,...>
// Mode<T,X> | ModeSet<Us...> -> ModeSet<Mode<T,X>, Us... >

template<typename T, T X, typename... Us>
constexpr ModeSet<Mode<T,X>, Us...> operator|(Mode<T,X>, ModeSet<Us...>)
{
    return {};
}

using example2_t = decltype(dotted|(arrows|sketchy));
//constexpr display_t<example2_t> X;


// ModeSet | ModeSet -> ModeSet
// e.g.: (a|b|...)|(x,y,...) -> <a,b,...,x,y,...>
// ModeSet<Ts...> | ModeSet<Us...> -> ModeSet<Ts..., Us... >

template<typename... Ts, typename... Us>
constexpr ModeSet<Ts..., Us...> operator|(ModeSet<Ts...>, ModeSet<Us...>)
{
    return {};
}

using example4_t = decltype((dotted|arrows)|(sketchy|green));
//constexpr display_t<example4_t> X;

using example5_t = decltype(dotted|arrows|sketchy|green);
//constexpr display_t<example5_t> X;


template<typename ModeExpression>
void drawLine(ModeExpression) // dummy implementation
{}

int main()
{
    drawLine(circles);
    drawLine(dotted|painterly);
    drawLine(sketchy|dotted|green);
    drawLine(plain|dashed|arrows|red);
    drawLine(solid|dashed|no_ends|blue);

    drawLine((dotted|arrows)|sketchy);
    drawLine(dotted|(arrows|sketchy));
    drawLine((dotted|arrows)|(sketchy|green));

    std::cout << "done.";
}
